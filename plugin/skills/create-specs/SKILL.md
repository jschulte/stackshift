---
name: create-specs
description: Transform reverse-engineering documentation into GitHub Spec Kit format. Initializes .specify/ directory, creates constitution.md, generates specifications from reverse-engineered docs, and sets up for /speckit slash commands. This is Step 3 of 6 in the reverse engineering process.
---

# Create Specifications (GitHub Spec Kit Integration)

**Step 3 of 6** in the Reverse Engineering to Spec-Driven Development process.

**Estimated Time:** 30 minutes
**Prerequisites:** Step 2 completed (`docs/reverse-engineering/` exists with 8 files)
**Output:** `.specify/` directory with GitHub Spec Kit structure

---

## When to Use This Skill

Use this skill when:
- You've completed Step 2 (Reverse Engineer)
- Have comprehensive documentation in `docs/reverse-engineering/`
- Ready to create formal specifications in GitHub Spec Kit format
- Want to leverage `/speckit` slash commands for implementation

**Trigger Phrases:**
- "Create specifications from documentation"
- "Transform docs into Spec Kit format"
- "Set up GitHub Spec Kit"
- "Initialize Spec Kit for this project"

---

## What This Skill Does

**Automatically** transforms reverse-engineering documentation into **GitHub Spec Kit format** using F002 automated spec generation:

1. **Read reverse engineering docs** - Parse `docs/reverse-engineering/functional-specification.md`
2. **Extract ALL features** - Identify every feature (complete, partial, missing)
3. **Generate constitution** - Create `.specify/memory/constitution.md` with project principles
4. **Create feature specs** - Generate `specs/###-feature-name/spec.md` for EVERY feature
5. **Implementation plans** - Create `plan.md` for PARTIAL and MISSING features only
6. **Enable slash commands** - Set up `/speckit.*` commands

**Critical**: This creates specs for **100% of features**, not just gaps!
- ‚úÖ Complete features get specs (for future spec-driven changes)
- ‚ö†Ô∏è Partial features get specs + plans (show what exists + what's missing)
- ‚ùå Missing features get specs + plans (ready to implement)

**Result:** Complete spec coverage - entire application under spec control.

---

## ü§ñ Execution Instructions

**IMPORTANT**: This skill uses automated spec generation tools from F002.

### Step 1: Call the MCP Tool

Run the `stackshift_create_specs` MCP tool to automatically generate ALL specifications:

**This tool will**:
- Parse `docs/reverse-engineering/functional-specification.md`
- Extract EVERY feature (complete, partial, missing)
- Generate constitution and ALL feature specs
- Create implementation plans for incomplete features

**Usage**:
```typescript
// Call the MCP tool
const result = await mcp.callTool('stackshift_create_specs', {
  directory: process.cwd()
});

// The tool will:
// 1. Read functional-specification.md
// 2. Create specs for ALL features (not just gaps!)
// 3. Mark implementation status (‚úÖ/‚ö†Ô∏è/‚ùå)
// 4. Generate plans for PARTIAL/MISSING features
// 5. Return summary showing complete coverage
```

**Expected output**:
- Constitution created
- 15-50 feature specs created (depending on app size)
- 100% feature coverage
- Implementation plans for incomplete features

### Step 2: Verify Success

After the tool completes, verify:
1. `.specify/memory/constitution.md` exists
2. `specs/###-feature-name/` directories created for ALL features
3. Each feature has `spec.md`
4. PARTIAL/MISSING features have `plan.md`

---

## If Automated Tool Fails

The MCP tool creates all Spec Kit files programmatically - it does NOT need `specify init`.

**The tool creates**:
- `.specify/memory/constitution.md` (from templates)
- `specs/###-feature-name/spec.md` (all features)
- `specs/###-feature-name/plan.md` (for incomplete features)
- `.claude/commands/speckit.*.md` (slash commands)

**If the MCP tool fails**, use the manual reconciliation prompt:

```bash
# Copy this prompt into Claude.ai:
cat web/reconcile-specs.md

# This will manually create all specs with 100% coverage
```

**DO NOT run `specify init`** - it requires GitHub API access and isn't needed since F002 creates all files directly.

This creates:
```
.specify/
‚îú‚îÄ‚îÄ memory/
‚îÇ   ‚îî‚îÄ‚îÄ constitution.md       # Project principles (will be generated)
‚îú‚îÄ‚îÄ templates/                # AI agent configs
‚îî‚îÄ‚îÄ scripts/                  # Automation utilities

specs/                        # Feature directories (will be generated)
‚îú‚îÄ‚îÄ FEATURE-ID-001/
‚îÇ   ‚îú‚îÄ‚îÄ spec.md              # Feature specification
‚îÇ   ‚îú‚îÄ‚îÄ plan.md              # Implementation plan
‚îÇ   ‚îî‚îÄ‚îÄ tasks.md             # Task breakdown (generated by /speckit.tasks)
‚îî‚îÄ‚îÄ FEATURE-ID-002/
    ‚îî‚îÄ‚îÄ ...
```

**Note:** Spec Kit uses `specs/FEATURE-ID/` directories (not `specs/`)

See [operations/init-speckit.md](operations/init-speckit.md)

### Step 2: Generate Constitution

From `docs/reverse-engineering/functional-specification.md`, create `.specify/memory/constitution.md`:

**Constitution includes:**
- **Purpose & Values** - Why this project exists, core principles
- **Technical Decisions** - Architecture choices with rationale
- **Development Standards** - Code style, testing requirements, review process
- **Quality Standards** - Performance, security, reliability requirements
- **Governance** - How decisions are made

**Use `/speckit.constitution` command:**
```
After generating initial constitution, user can run:
> /speckit.constitution

To refine and update the constitution interactively
```

See [operations/generate-constitution.md](operations/generate-constitution.md)

### Step 3: Generate Specifications

Transform `docs/reverse-engineering/functional-specification.md` into individual feature specs in `specs/FEATURE-ID/`:

**Recommended:** Use the Task tool with `subagent_type=stackshift:technical-writer` for efficient, parallel spec generation.

**Directory Structure (per GitHub Spec Kit conventions):**

Each feature gets its own directory:
```
specs/001-user-authentication/
  ‚îú‚îÄ‚îÄ spec.md              # Feature specification
  ‚îî‚îÄ‚îÄ plan.md              # Implementation plan
```

**spec.md format:**

```markdown
# Feature: User Authentication

## Status
‚ö†Ô∏è **PARTIAL** - Backend complete, frontend missing login UI

## Overview
[Description of what this feature does]

## User Stories
- As a user, I want to register an account so that I can save my data
- As a user, I want to log in so that I can access my dashboard

## Acceptance Criteria
- [ ] User can register with email and password
- [x] User can log in with credentials
- [ ] User can reset forgotten password
- [x] JWT tokens issued on successful login

## Technical Requirements
- Authentication method: JWT
- Password hashing: bcrypt
- Session duration: 24 hours
- API endpoints:
  - POST /api/auth/register
  - POST /api/auth/login
  - POST /api/auth/reset-password

## Implementation Status
**Completed:**
- ‚úÖ Backend API endpoints (all 3)
- ‚úÖ Database user model
- ‚úÖ JWT token generation

**Missing:**
- ‚ùå Frontend login page
- ‚ùå Frontend registration page
- ‚ùå Password reset UI
- ‚ùå Token refresh mechanism

## Dependencies
None

## Related Specifications
- user-profile.md (depends on authentication)
- authorization.md (extends authentication)
```

**Use `/speckit.specify` command:**
```
After generating initial specs, user can run:
> /speckit.specify

To create additional specifications or refine existing ones
```

See [operations/generate-specifications.md](operations/generate-specifications.md)

### Step 4: Generate Implementation Plans

For each **PARTIAL** or **MISSING** feature, create `plan.md` in the feature's directory:

**Location:** `specs/FEATURE-ID/plan.md`

**Format:**

```markdown
# Implementation Plan: User Authentication Frontend

## Goal
Complete the frontend UI for user authentication (login, registration, password reset)

## Current State
- Backend API fully functional
- No frontend UI components exist
- User lands on placeholder page

## Target State
- Complete login page with form validation
- Registration page with email verification
- Password reset flow (email + new password)
- Responsive design for mobile/desktop

## Technical Approach
1. Create React components using existing UI library
2. Integrate with backend API endpoints
3. Add form validation with Zod
4. Implement JWT token storage (localStorage)
5. Add route protection for authenticated pages

## Tasks
- [ ] Create LoginPage component
- [ ] Create RegistrationPage component
- [ ] Create PasswordResetPage component
- [ ] Add form validation
- [ ] Integrate with API endpoints
- [ ] Add loading and error states
- [ ] Write component tests
- [ ] Update routing configuration

## Risks & Mitigations
- Risk: Token storage in localStorage (XSS vulnerability)
  - Mitigation: Consider httpOnly cookies instead
- Risk: No rate limiting on frontend
  - Mitigation: Add rate limiting to API endpoints

## Testing Strategy
- Unit tests for form validation logic
- Integration tests for API calls
- E2E tests for complete auth flow

## Success Criteria
- All acceptance criteria from specification met
- No security vulnerabilities
- Pass all tests
- UI matches design system
```

**Use `/speckit.plan` command:**
```
After generating initial plans, user can run:
> /speckit.plan

To create or refine implementation plans
```

See [operations/generate-plans.md](operations/generate-plans.md)

### Step 5: Mark Implementation Status

In each specification, clearly mark what's implemented vs missing:

- ‚úÖ **COMPLETE** - Fully implemented and tested
- ‚ö†Ô∏è **PARTIAL** - Partially implemented (note what exists vs what's missing)
- ‚ùå **MISSING** - Not started

This allows `/speckit.analyze` to verify consistency.

---

## GitHub Spec Kit Slash Commands

After setting up specs, these commands become available:

### Validation & Analysis

```bash
# Check consistency between specs and implementation
> /speckit.analyze

# Identifies:
# - Specs marked COMPLETE but implementation missing
# - Implementation exists but not in spec
# - Inconsistencies between related specs
```

### Implementation

```bash
# Generate tasks from implementation plan
> /speckit.tasks

# Implement a specific feature
> /speckit.implement <specification-name>

# Runs through implementation plan step-by-step
# Updates implementation status as it progresses
```

### Clarification

```bash
# Resolve underspecified areas
> /speckit.clarify

# Interactive Q&A to fill in missing details
# Similar to our complete-spec skill
```

---

## Output Structure

After this skill completes:

```
.specify/
‚îú‚îÄ‚îÄ memory/
‚îÇ   ‚îî‚îÄ‚îÄ constitution.md                    # Project principles
‚îú‚îÄ‚îÄ templates/
‚îî‚îÄ‚îÄ scripts/

specs/                                     # Feature directories
‚îú‚îÄ‚îÄ 001-user-authentication/
‚îÇ   ‚îú‚îÄ‚îÄ spec.md                           # ‚ö†Ô∏è PARTIAL
‚îÇ   ‚îî‚îÄ‚îÄ plan.md                           # Implementation plan
‚îú‚îÄ‚îÄ 002-fish-management/
‚îÇ   ‚îú‚îÄ‚îÄ spec.md                           # ‚ö†Ô∏è PARTIAL
‚îÇ   ‚îî‚îÄ‚îÄ plan.md
‚îú‚îÄ‚îÄ 003-analytics-dashboard/
‚îÇ   ‚îú‚îÄ‚îÄ spec.md                           # ‚ùå MISSING
‚îÇ   ‚îî‚îÄ‚îÄ plan.md
‚îî‚îÄ‚îÄ 004-photo-upload/
    ‚îú‚îÄ‚îÄ spec.md                           # ‚ö†Ô∏è PARTIAL
    ‚îî‚îÄ‚îÄ plan.md

docs/reverse-engineering/  # Keep original docs for reference
‚îú‚îÄ‚îÄ functional-specification.md
‚îú‚îÄ‚îÄ data-architecture.md
‚îî‚îÄ‚îÄ ...
```

### For Greenfield Separate Directory

If `greenfield_location` is an absolute path (e.g., `~/git/my-new-app`):

**After Gear 3, .specify/ exists in BOTH locations:**

**Original repo:**
```
~/git/my-app/
‚îú‚îÄ‚îÄ [original code]
‚îú‚îÄ‚îÄ .specify/           # Created here first
‚îî‚îÄ‚îÄ docs/
```

**New repo (created and initialized):**
```
~/git/my-new-app/
‚îú‚îÄ‚îÄ .specify/           # COPIED from original repo
‚îú‚îÄ‚îÄ README.md
‚îî‚îÄ‚îÄ .gitignore
```

**Why copy?**
- New repo needs specs for `/speckit.*` commands
- New repo is self-contained and spec-driven
- Can develop independently going forward
- Original repo keeps specs for reference

---

## Integration with Original Toolkit

**Reverse-Engineered Docs ‚Üí Spec Kit Artifacts:**

| Original Doc | Spec Kit Artifact | Location |
|-------------|------------------|----------|
| functional-specification.md | constitution.md | `.specify/memory/` |
| functional-specification.md | Individual feature specs | `specs/` |
| data-architecture.md | Technical details in specs | Embedded in specifications |
| operations-guide.md | Operational notes in constitution | `.specify/memory/constitution.md` |
| technical-debt-analysis.md | Implementation plans | `specs/` |

**Keep both:**
- `docs/reverse-engineering/` - Comprehensive reference docs
- `.specify/memory/` - Spec Kit format for `/speckit` commands

---

## Success Criteria

After running this skill, you should have:

- ‚úÖ `.specify/` directory initialized
- ‚úÖ `constitution.md` created with project principles
- ‚úÖ Individual feature specifications in `specs/`
- ‚úÖ Implementation plans for PARTIAL/MISSING features
- ‚úÖ Implementation status clearly marked (‚úÖ/‚ö†Ô∏è/‚ùå)
- ‚úÖ `/speckit.*` slash commands available
- ‚úÖ Ready to use `/speckit.analyze` to validate
- ‚úÖ Ready to use `/speckit.implement` to fill gaps

---

## Next Step

Once specifications are created in Spec Kit format, proceed to:

**Step 4: Gap Analysis** - Use `/speckit.analyze` to identify inconsistencies and the gap-analysis skill to create prioritized implementation plan.

---

## Example Workflow

```bash
# This skill runs
1. specify init my-app
2. Generate constitution.md from functional-specification.md
3. Create individual feature specs from functional requirements
4. Mark implementation status (‚úÖ/‚ö†Ô∏è/‚ùå)
5. Generate implementation plans for gaps

# User can then run
> /speckit.analyze
# Shows: "5 PARTIAL features, 3 MISSING features, 2 inconsistencies"

> /speckit.implement user-authentication
# Walks through implementation plan step-by-step

> /speckit.specify
# Add new features as needed
```

---

## Technical Notes

- Spec Kit uses `.specify/` directory (not `specs/`)
- Specifications are markdown files, not JSON/YAML
- Implementation status uses emoji markers: ‚úÖ ‚ö†Ô∏è ‚ùå
- `/speckit` commands are slash commands in Claude Code, not CLI
- Constitution is a living document, update as project evolves
- Keep reverse-engineering docs as comprehensive reference
- Use `stackshift:technical-writer` agent for efficient parallel spec generation
- Always use `--ai claude` flag with `specify init` for non-interactive mode

---

**Remember:** This integrates your reverse-engineered codebase with GitHub Spec Kit, enabling the full `/speckit.*` workflow for ongoing development.
